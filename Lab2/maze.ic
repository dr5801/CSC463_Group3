/**
 * Authors: Drew Rife, Brett Pare, Michael Pulliam
 * Professor: Dr. Girard
 * CSC 463
 * Lab 2: Use two touch sensors to navigate out of a maze
*/

#define RIGHT_MOTOR 1
#define LEFT_MOTOR 0
#define RIGHT_SENSOR 15
#define LEFT_SENSOR 10
#define LEFT_DIRECTION 0
#define RIGHT_DIRECTION 1

struct Direction {
    int forward;
    int right;
    int left;
    int backward;
} direction = {0, 1, 2, 3};

int hitWall;
int currentState = direction.forward;

void turn(int turnDirection)
{
    float initialTime;
    float elapsedTime;
    initialTime = seconds();
    while(((initialTime+2.1) > elapsedTime)) {
        switch(turnDirection)
          {
            case direction.right:
              bk(RIGHT_MOTOR);
              fd(LEFT_MOTOR);
              break;
            case direction.left:
              bk(LEFT_MOTOR);
              fd(RIGHT_MOTOR);
              break;
        }
        elapsedTime = seconds();
    }
}

/* moves the robot forward */
void moveForward()
{
    float secondsToRun = 5.0;
    float initialTime = seconds();
    float timeOut = initialTime + secondsToRun;
    
    while( (timeOut > seconds()) && !hitWall ) {
        motor(LEFT_MOTOR, 20);
        motor(RIGHT_MOTOR, 20);
        
        if( digital(LEFT_SENSOR) || digital(RIGHT_SENSOR) ) {
            hitWall = 1;
        } 
    }
    
    if( hitWall ) {
        if( digital(LEFT_SENSOR) ) {
            waitForOtherSensor(RIGHT_SENSOR);
        }
        else {
            waitForOtherSensor(LEFT_SENSOR);
        }
        
        moveBackward(3.0);
    }    
}

/* moves the robot forward */
void moveBackward(float timeToRun)
{
    float initialTime;
    float timeElapsed;
    
    initialTime = seconds();
    while(initialTime+timeToRun > timeElapsed) {
        motor(LEFT_MOTOR, -30);
        motor(RIGHT_MOTOR, -30);
        timeElapsed = seconds();
    }
    
}

void waitForOtherSensor(int sensor) 
{
    if( sensor == RIGHT_SENSOR ) {
        off(LEFT_MOTOR);
        motor(RIGHT_MOTOR, 50);
    }
    else {
        off(RIGHT_MOTOR);
        motor(LEFT_MOTOR, 50);
    }
    
    while( !digital(sensor) );
}

void decideNextTurn(int lastTurn)
{
    switch(lastTurn)
      {
        case direction.forward:
          currentState = direction.right;
        break;
        case direction.right:
          currentState = direction.left;
        break;
        case direction.left:
          currentState = direction.backward;
        break;
        case direction.backward:
          currentState = direction.forward;
        break;
    }
}


/**
 * main method to run the robot 
 */
void main() 
{   
    float initialTime;
    float elapsedTime;
    int lastTurn = direction.forward;
    /* waits for start button to be pressed */
    while( !start_button() );
    
    while( !stop_button() ) {
        switch(currentState)
          {
            case direction.forward:
              moveForward();
              if( hitWall ) {
                  hitWall = 0;
                  decideNextTurn(lastTurn);
              }
              break;
            case direction.right:
                turn(direction.right);
              lastTurn = direction.right;
              currentState = direction.forward;
              break;
            case direction.left:
              turn(direction.left);
              lastTurn = direction.left;
              currentState = direction.forward;
              break;
            case direction.backward:
              turn(direction.left);
              turn(direction.left);
              lastTurn = direction.forward;
              currentState = direction.forward;
              break;
        }
    }
}
