/**
 * Authors: Drew Rife, Brett Pare, Michael Pulliam
 * Professor: Dr. Girard
 * CSC 463
 * Lab 2: Use touch sensors to walk robot out of the maze
 */

#define RIGHT_MOTOR 2
#define LEFT_MOTOR 0
#define LIGHT_SENSOR 4
#define LEFT_IR 5
#define RIGHT_IR 6

struct Direction 
{
    int forward;
    int right;
    int left;
    int backward;
} direction = {0, 1, 2, 3};

/* flag for if the robot hit the wall */
int hitWall;

/**
 * Turns the robot in the specific direction.
 * It turns for 2.05 seconds which is a 90 degree angle
 */
void turn(int turnDirection)
{
    float initialTime;
    float elapsedTime;
    switch(turnDirection)
      {
        case direction.right:
          bk(RIGHT_MOTOR);
        fd(LEFT_MOTOR);
        break;
        case direction.left:
          bk(LEFT_MOTOR);
        fd(RIGHT_MOTOR);
        break;
    }
    
    initialTime = seconds();
    while(((initialTime+2.25) > seconds()));
}

/**
 * Moves the robot forward for 5 seconds or until it hits a wall.
 */
float moveForwardIR()
{
    float initialTime;
    float timeOut;
    float timeElapsed = 0.0;
    float secondsToRun = 6.0;
    
    hitWall = 0;
    initialTime = seconds();
    timeOut = initialTime + secondsToRun;
    fd(LEFT_MOTOR);
    fd(RIGHT_MOTOR);
    //motor(LEFT_MOTOR, 100);
    //motor(RIGHT_MOTOR, 100);
    while( (timeOut > seconds()) && !hitWall ) 
      {        
        if( analog(LEFT_IR) < 50 || analog(RIGHT_IR) < 50 ) 
          {
            hitWall = 1;
        } 
    }
    timeElapsed = seconds() - initialTime;
    
    /* if the robot hit the wall */
    if( hitWall ) 
      {
        /* if the left sensor was touched, wait for the right sensor to touch */
        if( analog(LEFT_IR) < 50 ) 
          {
            waitForOtherSensor(RIGHT_IR);
        }
        /* else the right sensor was touched, wait for the left sensor to touch */
        else 
          {
            waitForOtherSensor(LEFT_IR);
        }
    }   
    
    return timeElapsed;
}

/**
 * move the robot backward for a specified time to run 
 */
void moveBackward(float timeToRun)
{
    float initialTime;
    float timeElapsed;
    
    initialTime = seconds();
    bk(LEFT_MOTOR);
    bk(RIGHT_MOTOR);
    //motor(LEFT_MOTOR, -100);
    //motor(RIGHT_MOTOR, -100);
    while(initialTime+timeToRun > seconds());    
}

/**
 * When one sensor is touched, turn off that sensor and continue to
 * power the other sensor until it touches the wall as well. 
 * This gets the robot directly squared.
 */
void waitForOtherSensor(int sensor) 
{
    int currentReading;
    int range = 5;
    if( sensor == RIGHT_IR ) 
      {
        //off(LEFT_MOTOR);
        //currentReading = analog(LEFT_IR);
        //motor(LEFT_MOTOR, -50);
        //motor(RIGHT_MOTOR, 50);
        //motor(RIGHT_MOTOR, 50);
        bk(LEFT_MOTOR);
        fd(RIGHT_MOTOR);
        while( analog(RIGHT_IR) >= (analog(LEFT_IR)+range) );
    }
    else 
      {
        //off(RIGHT_MOTOR);
        //currentReading = analog(RIGHT_IR);
        //motor(RIGHT_MOTOR, -50);
        //motor(LEFT_MOTOR, 50);
        //motor(LEFT_MOTOR, 50);
        bk(RIGHT_MOTOR);
        fd(LEFT_MOTOR);
        while( analog(LEFT_IR) >= (analog(RIGHT_IR)+range) );
    }
    
    //alloff();
}

/**
 * evaluates the current state, whether it hit a wall, and sets the next state
 */
int evaluate(int currentState, float elapsedTime)
{
    int nextState;
    
    /**
  * if a wall was hit, move backward to original position.
  * Then select next state to transition to
  */
    if( hitWall )
      {
        moveBackward(elapsedTime);
        
        /* select next state to transition to */
        switch(currentState)
          {
            case direction.forward:
              nextState = direction.right;
            break;
            case direction.right:
              nextState = direction.backward;
            break;
            case direction.backward:
              nextState = direction.left;
            break;
            case direction.left:
              nextState = direction.forward;
            break;
        }    
    }
    else 
      {
        /* a wall wasn't hit so keep moving forward */
        nextState = direction.forward;
    }
    
    return nextState; 
}

int foundLight()
{
    if(analog(LIGHT_SENSOR) > 150) {
        return 0;
    }
    else {
        return 1;
    }
}

void useIR()
{
    float initialTime;
    float elapsedTime;
    int currentState = direction.forward;
    int lastState = direction.forward;
    int lightFound = 0;
    
    while(!lightFound){
        switch(currentState)
          {
            case direction.forward:
              elapsedTime = moveForwardIR();
              break;
            case direction.right:
              turn(direction.right);
              break;
            case direction.backward:
              turn(direction.right);
              turn(direction.right);
              break;
            case direction.left:
              turn(direction.left);
              break;
        }
        
        if(!foundLight()) {
            if(currentState != direction.forward) {
                elapsedTime = moveForwardIR();
            }
            
            currentState = evaluate(currentState, elapsedTime);
        }
        else {
            lightFound = 1;
        }
    }   
}

void useLightSensor()
{
    fd(LEFT_MOTOR);
    fd(RIGHT_MOTOR);
    while(analog(LIGHT_SENSOR) < 200);   
}

/**
 * main method to run the robot 
 */
int main() 
{       
    /* waits for start button to be pressed */
    while( !start_button() );
    
    useIR();
    useLightSensor();
    alloff();
    return 0;
}
