/**
 * Authors: Drew Rife, Brett Pare, Michael Pulliam
 * Professor: Dr. Girard
 * CSC 463
 * Lab 2: Use touch sensors to walk robot out of the maze
 */

#define RIGHT_MOTOR 2
#define LEFT_MOTOR 0
#define RIGHT_SENSOR 8
#define LEFT_SENSOR 7

struct Direction 
{
    int forward;
    int right;
    int left;
    int backward;
} direction = {0, 1, 2, 3};

/* flag for if the robot hit the wall */
int hitWall;
int currentAction = direction.forward;
int consecutiveTurns;

float rewardValues[4];


/**
 * Turns the robot in the specific direction.
 * It turns for 2.05 seconds which is a 90 degree angle
 */
void turn(int turnDirection)
{
    float initialTime;
    float elapsedTime;
    initialTime = seconds();
    while(((initialTime+2.05) > elapsedTime)) 
 {
        switch(turnDirection)
        {
            case direction.right:
              bk(RIGHT_MOTOR);
              fd(LEFT_MOTOR);
              break;
            case direction.left:
              bk(LEFT_MOTOR);
              fd(RIGHT_MOTOR);
              break;
        }
        elapsedTime = seconds();
    }
}

/**
 * Moves the robot forward for 5 seconds or until it hits a wall.
 */
float moveForward()
{
    float timeElapsed = 0.0;
    float secondsToRun = 5.0;
    float initialTime = seconds();
    float timeOut = initialTime + secondsToRun;
    
    hitWall = 0;
    while( (timeOut > seconds()) && !hitWall ) 
 {
        motor(LEFT_MOTOR, 40);
        motor(RIGHT_MOTOR, 40);
        
        if( digital(LEFT_SENSOR) || digital(RIGHT_SENSOR) ) 
  {
            hitWall = 1;
        } 
    }
    timeElapsed = seconds() - initialTime;
    
 /* if the robot hit the wall */
    if( hitWall ) 
 {
  /* if the left sensor was touched, wait for the right sensor to touch */
        if( digital(LEFT_SENSOR) ) 
  {
            waitForOtherSensor(RIGHT_SENSOR);
        }
  /* else the right sensor was touched, wait for the left sensor to touch */
        else 
  {
            waitForOtherSensor(LEFT_SENSOR);
        }
    }   
    
    return timeElapsed;
}

/**
 * move the robot backward for a specified time to run 
 */
void moveBackward(float timeToRun)
{
    float initialTime;
    float timeElapsed;
    
    initialTime = seconds();
    while(initialTime+timeToRun > timeElapsed) 
 {
        motor(LEFT_MOTOR, -40);
        motor(RIGHT_MOTOR, -40);
        timeElapsed = seconds();
    }    
}

/**
 * When one sensor is touched, turn off that sensor and continue to
 * power the other sensor until it touches the wall as well. 
 * This gets the robot directly squared.
 */
void waitForOtherSensor(int sensor) 
{
    if( sensor == RIGHT_SENSOR ) 
 {
        off(LEFT_MOTOR);
        motor(RIGHT_MOTOR, 50);
    }
    else 
 {
        off(RIGHT_MOTOR);
        motor(LEFT_MOTOR, 50);
    }
    
 /* wait until the sensor touches the wall */
    while( !digital(sensor) );
}

int getNextAction()
{
    int i;
    int j;
    int highest;
    float highestValue = 0.0;
    int tiedHighestValues = 0;
    int index[4];
    for(i = 0; i < 4; i++)
    {
        if(rewardValues[i] > highestValue) {
            highestValue = rewardValues[i];
            highest = i;
        }
        else if(rewardValues[i] == highestValue) {
            tiedHighestValues++;
        }
    }
    
    if(tiedHighestValues > 0) {
        j = 0;
        for(i = 0; i < 4; i++) {
            if(rewardValues[i] == highestValue) {
                index[j] = i;
                j++;
            }
        }
        
        currentAction = ((int)seconds() % (tiedHighestValues-1));
        return currentAction;
        
    } else {
      currentAction = highest;
      return highest; 
    }
}

/**
 * evaluates the current state, whether it hit a wall, and sets the next state
 */
int evaluate(int previousAction, float elapsedTime)
{
    int nextState;
    int nextAction;
 
 /**
  * if a wall was hit, move backward to original position.
  * Then select next state to transition to
  */
    if( hitWall ) {
        rewardValues[previousAction] -= 0.5;
    }
    else {
        rewardValues[previousAction] += 1.0;
    }
    return getNextAction();
}

/**
 * main method to run the robot 
 */
void main() 
{   
    float initialTime;
    float elapsedTime;
    int lastTurn = direction.forward;
 
    /* waits for start button to be pressed */
    while( !start_button() );
    
    while( !stop_button() ) 
 {
        switch(currentAction)
        {
            case direction.forward:
              elapsedTime = moveForward();
              rewardValues[direction.forward] += 0.1;
              currentAction = evaluate(currentAction, elapsedTime);
              break;
            case direction.right:
              turn(direction.right);
              rewardValues[direction.right] += 0.1;
              elapsedTime = moveForward();
              currentAction = evaluate(currentAction, elapsedTime);
              break;
            case direction.backward:
              turn(direction.right);
              turn(direction.right);
              rewardValues[direction.backward] += 0.1;
              elapsedTime = moveForward();
              currentAction = evaluate(currentAction, elapsedTime);
              break;
            case direction.left:
              turn(direction.left);
              rewardValues[direction.left] += 0.1;
              elapsedTime = moveForward();
              currentAction = evaluate(currentAction, elapsedTime);
              break;
        }
    }
}
